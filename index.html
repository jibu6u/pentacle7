<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EMDR 3D Globe — WebXR Demo (with Pentacle 5)</title>
  <style>
    html, body { margin:0; padding:0; background:#000; color:#eee; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; height:100%; overflow:hidden; }
    #ui { position: fixed; top: 12px; left: 12px; z-index: 2000; background: rgba(0,0,0,0.55); backdrop-filter: blur(4px); border:1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 10px 12px; max-width: 520px; line-height: 1.2; }
    #ui h1 { font-size: 14px; margin: 0 0 6px; font-weight: 700; color:#fff; }
    #ui h2 { font-size: 12px; margin: 10px 0 6px; font-weight: 700; color:#fff; opacity:0.9; }
    #ui .row { display:flex; align-items:center; gap:8px; margin:6px 0; }
    #ui label { width: 170px; font-size: 12px; color:#ddd; }
    #ui input[type="range"] { flex:1; }
    #ui input[type="color"] { width: 48px; height: 24px; padding: 0; border: none; }
    #ui select, #ui button { background:#111; color:#eee; border-radius:8px; border:1px solid #333; padding:6px 8px; }
    #ui button { cursor:pointer; }
    #ui button:hover { background:#1b1b1b; }
    #hint { position: fixed; bottom: 10px; left: 12px; color:#aaa; font-size: 12px; z-index: 2000; }
    #fileStatus, #tickStatus, #vid360Status, #vid2dStatus { font-size: 11px; color:#aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 420px; }
    #showUiBtn { position: fixed; top: 12px; left: 12px; z-index: 9999; background: rgba(17,17,17,0.95); color:#eee; border:1px solid #333; border-radius:8px; padding:6px 8px; cursor:pointer; display:none; }
    #errorOverlay { position: fixed; left: 12px; right: 12px; top: 12px; z-index: 99999; background: rgba(128,0,0,0.9); color: #fff; padding: 10px; border-radius: 8px; display: none; font-size: 13px; max-height: 40vh; overflow:auto; }
  </style>
</head>
<body>

<div id="ui">
  <h1>EMDR 3D Globe — Demo</h1>

  <div class="row" style="justify-content:flex-start; gap:6px;">
    <button id="startBtn">재생 시작</button>
  </div>

  <div class="row">
    <label>색상(Color)</label>
    <input id="color" type="color" value="#ffffff" />
    <button id="toggleUiBtn" title="UI 숨기기/표시">UI 숨기기</button>
    <button id="pauseBtn" title="일시정지/재생">일시정지</button>
  </div>

  <div class="row"><label>크기(Size, m)</label><input id="size" type="range" min="0.005" max="0.30" step="0.005" value="0.06" /></div>
  <div class="row"><label>속도(Speed)</label><input id="speed" type="range" min="0.1" max="3.0" step="0.1" value="1.0" /></div>
  <div class="row"><label>머무름(Dwell s)</label><input id="dwell" type="range" min="0" max="2.0" step="0.05" value="0.40" /></div>
  <div class="row"><label>기본거리(Base m)</label><input id="base" type="range" min="0.5" max="3.5" step="0.1" value="1.8" /></div>
  <div class="row"><label>범위 X (m)</label><input id="ampx" type="range" min="0.01" max="1.5" step="0.01" value="0.60" /></div>
  <div class="row"><label>범위 Y (m)</label><input id="ampy" type="range" min="0.01" max="1.2" step="0.01" value="0.35" /></div>
  <div class="row"><label>범위 Z (m)</label><input id="ampz" type="range" min="0.01" max="1.5" step="0.01" value="0.45" /></div>
  <div class="row"><label>랜덤 이동</label><input id="randomize" type="checkbox" checked /></div>

  <div class="row"><label>이동 모드</label>
    <select id="moveMode">
      <option value="random">랜덤</option>
      <option value="presetAB">프리셋 A×N → B 루프</option>
      <option value="mobiusA">모비우스 A</option>
      <option value="mobiusB">모비우스 B</option>
      <option value="hvLoop">HV 루프</option>
      <option value="topLeftSet">TopLeft 세트</option>
      <option value="complex3D9">Complex 3D9</option>
      <option value="pentacle1">펜타클 1</option>
      <option value="pentacle3">펜타클 3</option>
      <option value="pentacle4">펜타클 4</option>
      <option value="pentacle5">펜타클 5</option>
    </select>
  </div>

  <div class="row">
    <label>A 반복 횟수 (≥3)</label>
    <input id="repeatA" type="range" min="3" max="20" step="1" value="3" />
    <span id="repeatAText" style="font-size:12px; color:#ccc; width:28px; text-align:right;">3</span>
  </div>

  <div class="row" style="justify-content:space-between; gap:6px;">
    <button id="pick">새 타깃/리셋</button>
    <button id="centerMe">내 앞에 맞추기</button>
  </div>

  <hr style="border-color:#222;">
  <h2>배경 오디오(루프)</h2>
  <div class="row"><label>배경 오디오</label><input id="audioFile" type="file" accept="audio/*" /></div>
  <div class="row"><label>배경 볼륨</label><input id="bgVol" type="range" min="0" max="1" step="0.01" value="1" /></div>
  <div id="fileStatus">오디오 미선택</div>

  <hr style="border-color:#222;">
  <h2>틱 사운드(멈춤 순간 짧게 재생)</h2>
  <div class="row">
    <label>프리셋 선택</label>
    <select id="tickPreset">
      <option value="none">— 프리셋 없음 (업로드 사용) —</option>
      <option value="beep">1. beep (sine)</option>
      <option value="click">2. click (short transient)</option>
      <option value="bell">3. bell (short tone)</option>
      <option value="pop">4. pop (low thud)</option>
      <option value="noise_hi">5. noise burst (hi)</option>
      <option value="noise_low">6. noise burst (low)</option>
      <option value="wood">7. woodblock-like</option>
    </select>
    <button id="testPreset" title="선택한 프리셋 미리듣기">미리듣기</button>
  </div>
  <div class="row"><label>틱 사운드 파일</label><input id="tickFile" type="file" accept="audio/*" /></div>
  <div class="row"><label>틱 볼륨</label><input id="tickVol" type="range" min="0" max="1" step="0.01" value="0.8" /></div>
  <div id="tickStatus">프리셋 또는 업로드로 선택하세요</div>

  <hr style="border-color:#222;">
  <h2>360° VR 배경 비디오 (Equirectangular)</h2>
  <div class="row"><label>360 비디오</label><input id="vid360" type="file" accept="video/*" /></div>
  <div class="row" style="justify-content:space-between; gap:6px;">
    <button id="play360">재생/일시정지</button>
    <button id="clear360">배경 비우기</button>
  </div>
  <div class="row"><label>360 볼륨</label><input id="vol360" type="range" min="0" max="1" step="0.01" value="0.8" /></div>
  <div id="vid360Status">360 비디오 미선택</div>

  <hr style="border-color:#222;">
  <h2>2D 비디오 스크린(월드 공간)</h2>
  <div class="row"><label>2D 비디오</label><input id="vid2d" type="file" accept="video/*" /></div>
  <div class="row" style="justify-content:space-between; gap:6px;">
    <button id="play2d">재생/일시정지</button>
    <button id="hide2d">표시/숨김</button>
  </div>
  <div class="row"><label>2D 볼륨</label><input id="vol2d" type="range" min="0" max="1" step="0.01" value="0.8" /></div>
  <div class="row"><label>스크린 거리(m)</label><input id="screenDist" type="range" min="0.8" max="3.0" step="0.1" value="1.6" /></div>
  <div class="row"><label>스크린 폭(m)</label><input id="screenWidth" type="range" min="0.8" max="4.0" step="0.1" value="2.4" /></div>
  <div id="vid2dStatus">2D 비디오 미선택</div>
</div>

<button id="showUiBtn">UI 표시</button>
<div id="errorOverlay"></div>
<div id="hint">Tip: 모든 세팅 후 **재생 시작** 버튼을 누르면 구가 나타나 움직입니다. (첫 사용자 입력 후 오디오/비디오 활성화)</div>

<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
  import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/webxr/VRButton.js';

  const errEl = document.getElementById('errorOverlay');
  function showError(msg){
    errEl.style.display = 'block';
    errEl.textContent = msg;
    console.error(msg);
  }
  window.addEventListener('error', (e)=> { showError('에러: ' + (e && e.message ? e.message : String(e))); });
  window.addEventListener('unhandledrejection', (ev)=> { showError('Unhandled Promise Rejection: ' + (ev && ev.reason ? ev.reason : String(ev))); });

  // Renderer / Scene / Camera
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.05, 100);
  camera.position.set(0, 1.6, 0.0);

  // Lights
  const amb = new THREE.AmbientLight(0xffffff, 0.35); scene.add(amb);
  const key = new THREE.PointLight(0xffffff, 1.0, 0, 2); key.position.set(2, 2, 1); scene.add(key);

  // Globe
  const baseRadius = 0.03;
  const geo = new THREE.SphereGeometry(baseRadius, 32, 32);
  const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x000000, emissiveIntensity: 0.0, roughness:0.2, metalness:0.0 });
  const sphere = new THREE.Mesh(geo, mat);
  sphere.visible = false;
  scene.add(sphere);

  // Params
  const params = {
    color: '#ffffff',
    sphereScale: 0.06,
    moveSpeed: 1.0,
    dwell: 0.40,
    base: 1.8,
    ampx: 0.60,
    ampy: 0.35,
    ampz: 0.45,
    randomize: true,
    moveMode: 'random',
    presetRepeatA: 3,
  };

  // Helpers & state
  let started = false;
  let paused = false;
  let wasBgPlaying = false, wasVid360Playing = false, wasVid2dPlaying = false;
  let currentTarget = new THREE.Vector3();
  const tmpPos = new THREE.Vector3();
  const tmpDir = new THREE.Vector3();
  const worldUp = new THREE.Vector3(0,1,0);
  let waitingAtTarget = false;
  let turnReadyAt = 0;
  const arrivalThreshSq = 0.02 * 0.02;

  function computeCenter(out){
    if (renderer.xr.isPresenting){
      const xrCam = renderer.xr.getCamera(camera);
      xrCam.getWorldPosition(tmpPos);
      xrCam.getWorldDirection(tmpDir);
      out.copy(tmpPos).add(tmpDir.multiplyScalar(params.base));
    } else {
      out.set(0, 1.6, 0).add(new THREE.Vector3(0,0,-params.base));
    }
  }
  function computeBasis(){
    const center = new THREE.Vector3(); computeCenter(center);
    const fwd = new THREE.Vector3();
    const xrCam = renderer.xr.isPresenting ? renderer.xr.getCamera(camera) : camera;
    xrCam.getWorldDirection(fwd).normalize();
    const right = new THREE.Vector3().crossVectors(fwd, worldUp).normalize();
    const up = new THREE.Vector3().crossVectors(right, fwd).normalize();
    return { center, fwd, right, up };
  }
  function makeRelPoint(basis, ox=0, oy=0, oz=0){
    const {center, fwd, right, up} = basis;
    return new THREE.Vector3().copy(center)
      .add(right.clone().multiplyScalar(ox))
      .add(up.clone().multiplyScalar(oy))
      .add(fwd.clone().multiplyScalar(oz));
  }

  // pickNewTarget (used by random mode)
  function pickNewTarget(init=false){
    const center = new THREE.Vector3(); computeCenter(center);
    const offset = new THREE.Vector3(
      THREE.MathUtils.randFloatSpread(params.ampx*2),
      THREE.MathUtils.randFloatSpread(params.ampy*2),
      THREE.MathUtils.randFloatSpread(params.ampz*2)
    );
    currentTarget.copy(center).add(offset);
    if (init) sphere.position.copy(currentTarget);
  }

  // Path builders (preserve pentacle1/3/4)
  function buildMobiusPath(basis, hand='A'){
    const xAmp = Math.max(0.05, params.ampx);
    const zAmp = Math.max(0.05, params.ampz) * 0.85;
    const N = 8; const pts = [];
    for(let i=0;i<=N;i++){
      const t = (hand==='A' ? i : (N - i)) * (2*Math.PI/N);
      const x = xAmp * Math.sin(t);
      const z = zAmp * Math.sin(2*t) * 0.5;
      pts.push(makeRelPoint(basis, x, 0, z));
    }
    return pts;
  }
  function buildHVLoop(basis){
    const x = Math.max(0.05, params.ampx); const y = Math.max(0.05, params.ampy);
    return [ makeRelPoint(basis,-x,0,0), makeRelPoint(basis,x,0,0), makeRelPoint(basis,0,y,0), makeRelPoint(basis,0,-y,0), makeRelPoint(basis,-x,0,0) ];
  }
  function buildTopLeftSet(basis){
    const x = Math.max(0.05, params.ampx); const y = Math.max(0.05, params.ampy);
    return [ makeRelPoint(basis,-x,y,0), makeRelPoint(basis,0,-y,0), makeRelPoint(basis,x,y,0), makeRelPoint(basis,-x,0,0), makeRelPoint(basis,-x,y,0) ];
  }
  function buildPatternA(basis){
    const x = Math.max(0.05, params.ampx), z = Math.max(0.05, params.ampz);
    return [ makeRelPoint(basis,0,0,+z), makeRelPoint(basis,0,0,-z), makeRelPoint(basis,-x,0,+z), makeRelPoint(basis,+x,0,+z), makeRelPoint(basis,0,0,+z) ];
  }
  function buildPatternB(basis){
    const x = Math.max(0.05, params.ampx), z = Math.max(0.05, params.ampz);
    return [ makeRelPoint(basis,0,0,+z), makeRelPoint(basis,0,0,-z), makeRelPoint(basis,+x,0,+z), makeRelPoint(basis,-x,0,+z), makeRelPoint(basis,0,0,+z) ];
  }
  function buildComplex3D9(basis){
    const x = Math.max(0.05, params.ampx), y = Math.max(0.05, params.ampy), z = Math.max(0.05, params.ampz);
    const pts = [];
    pts.push(makeRelPoint(basis,-x,0.15*y,-0.20*z));
    pts.push(makeRelPoint(basis,-0.2*x,0.80*y,0.25*z));
    pts.push(makeRelPoint(basis,+x,0.10*y,1.00*z));
    pts.push(makeRelPoint(basis,-0.60*x,-0.40*y,0.50*z));
    pts.push(makeRelPoint(basis,0.0,0.20*y,-1.00*z));
    pts.push(makeRelPoint(basis,+0.50*x,-0.50*y,-0.30*z));
    pts.push(makeRelPoint(basis,-0.90*x,0.50*y,0.10*z));
    pts.push(makeRelPoint(basis,+0.80*x,-0.20*y,0.20*z));
    pts.push(makeRelPoint(basis,0.0,-1.00*y,0.60*z));
    return pts;
  }

  function buildPentacle1(basis){
    const spread = Math.max(0.06, Math.min(params.ampx, params.ampz) * 0.6);
    const depthOffset = Math.max(0.05, params.ampz * 0.25);
    const pts = []; const startAngle=-Math.PI/2;
    for(let i=0;i<5;i++){
      const angle = startAngle + i*(2*Math.PI/5);
      const x = spread*Math.cos(angle);
      const y = spread*0.25*Math.sin(angle);
      const z = (i%2===0)? depthOffset*0.12 : -depthOffset*0.08;
      pts.push(makeRelPoint(basis,x,y,z));
    }
    pts[0].add(basis.up.clone().multiplyScalar(Math.max(spread*0.6, params.ampy*0.5)));
    return pts.concat([pts[0]]);
  }

  function buildPentacle3(basis){
    const baseSpread = Math.max(0.06, Math.min(params.ampx, params.ampz) * 0.6);
    const spread = baseSpread * 3.0;
    const depthOffset = Math.max(0.05, params.ampz * 0.25) * 3.0;
    const pts=[]; const startAngle=-Math.PI/2;
    for(let i=0;i<5;i++){
      const angle=startAngle + i*(2*Math.PI/5);
      const x=spread*Math.cos(angle);
      const y=spread*0.25*Math.sin(angle);
      const z=(i%2===0)? depthOffset*0.12 : -depthOffset*0.08;
      pts.push(makeRelPoint(basis,x,y,z));
    }
    pts[0].add(basis.up.clone().multiplyScalar(Math.max(spread*0.6, params.ampy*1.5)));
    pts[2].add(basis.up.clone().multiplyScalar(-Math.max(spread*0.9, params.ampy*1.2)));
    return pts.concat([pts[0]]);
  }

  function buildPentacle4(basis){
    const baseSpread = Math.max(0.06, Math.min(params.ampx, params.ampz) * 0.6);
    const spread = baseSpread * 3.0;
    const depthOffset = Math.max(0.05, params.ampz * 0.25) * 3.0;
    const pts=[]; const startAngle=-Math.PI/2;
    for(let i=0;i<5;i++){
      const angle=startAngle + i*(2*Math.PI/5);
      const x=spread*Math.cos(angle);
      const y=spread*0.25*Math.sin(angle);
      const z=(i%2===0)? depthOffset*0.12 : -depthOffset*0.08;
      pts.push(makeRelPoint(basis,x,y,z));
    }
    pts[0].add(basis.up.clone().multiplyScalar(Math.max(spread*0.6, params.ampy*1.5)));
    // move left-side index 3 deeper (appear behind)
    pts[3].add(basis.fwd.clone().multiplyScalar(Math.max(spread*0.8, params.ampz*0.8)));
    return pts.concat([pts[0]]);
  }

  // NEW: Pentacle 5 — same as pentacle4 but ensure one of the middle (non-top) points is placed well below the screen
  function buildPentacle5(basis){
    const baseSpread = Math.max(0.06, Math.min(params.ampx, params.ampz) * 0.6);
    const spread = baseSpread * 3.0;
    const depthOffset = Math.max(0.05, params.ampz * 0.25) * 3.0;
    const pts=[]; const startAngle=-Math.PI/2;
    for(let i=0;i<5;i++){
      const angle=startAngle + i*(2*Math.PI/5);
      const x=spread*Math.cos(angle);
      const y=spread*0.25*Math.sin(angle);
      const z=(i%2===0)? depthOffset*0.12 : -depthOffset*0.08;
      pts.push(makeRelPoint(basis,x,y,z));
    }
    // top boost
    pts[0].add(basis.up.clone().multiplyScalar(Math.max(spread*0.6, params.ampy*1.5)));
    // keep left-side depth shift from pentacle4 so shapes look similar
    pts[3].add(basis.fwd.clone().multiplyScalar(Math.max(spread*0.8, params.ampz*0.8)));
    // Additional: move one of the middle points (index 2) DOWN well below the screen
    // so it appears under the screen (negative up direction)
    const downBoost = Math.max(spread * 1.2, params.ampy * 1.8);
    pts[2].add(basis.up.clone().multiplyScalar(-downBoost));
    return pts.concat([pts[0]]);
  }

  // Preset state
  let presetPhase = 'A';
  let aRemain = params.presetRepeatA;
  let bRemain = 1;
  let pathPoints = [];
  let pathIdx = 0;

  function chooseNextPattern(basis){
    if (presetPhase === 'A'){
      if (aRemain > 0){ aRemain--; if (aRemain === 0){ presetPhase = 'B'; bRemain = 1; } return buildPatternA(basis); }
      presetPhase = 'B'; bRemain = 1; return buildPatternB(basis);
    } else {
      if (bRemain > 0){ bRemain--; if (bRemain === 0){ presetPhase = 'A'; aRemain = Math.max(3, params.presetRepeatA); } return buildPatternB(basis); }
      presetPhase = 'A'; aRemain = Math.max(3, params.presetRepeatA); return buildPatternA(basis);
    }
  }

  function buildNextPath(placeSphere=false){
    const basis = computeBasis();
    if (params.moveMode === 'presetAB') pathPoints = chooseNextPattern(basis);
    else if (params.moveMode === 'mobiusA' || params.moveMode === 'mobiusB') pathPoints = buildMobiusPath(basis, params.moveMode === 'mobiusA' ? 'A' : 'B');
    else if (params.moveMode === 'hvLoop') pathPoints = buildHVLoop(basis);
    else if (params.moveMode === 'topLeftSet') pathPoints = buildTopLeftSet(basis);
    else if (params.moveMode === 'complex3D9') pathPoints = buildComplex3D9(basis);
    else if (params.moveMode === 'pentacle1') pathPoints = buildPentacle1(basis);
    else if (params.moveMode === 'pentacle3') pathPoints = buildPentacle3(basis);
    else if (params.moveMode === 'pentacle4') pathPoints = buildPentacle4(basis);
    else if (params.moveMode === 'pentacle5') pathPoints = buildPentacle5(basis);
    else { const center = new THREE.Vector3(); computeCenter(center); pathPoints = [center]; }

    pathIdx = 0;
    if (placeSphere && pathPoints.length > 0){
      sphere.position.copy(pathPoints[0]);
      waitingAtTarget = false; turnReadyAt = 0;
      pathIdx = (pathPoints.length > 1 ? 1 : 0);
    }
    currentTarget.copy(pathPoints[pathIdx]);
  }
  function resetPreset(placeSphere=true){ presetPhase = 'A'; aRemain = Math.max(3, params.presetRepeatA); bRemain = 1; buildNextPath(placeSphere); }
  function resetMotion(placeSphere=true){ if (params.moveMode === 'presetAB') resetPreset(placeSphere); else buildNextPath(placeSphere); }
  function nextPresetTarget(){ pathIdx++; if (!pathPoints || pathIdx >= pathPoints.length){ buildNextPath(false); pathIdx = 0; } currentTarget.copy(pathPoints[pathIdx]); }

  // UI wiring
  const $ = (sel)=>document.querySelector(sel);
  const startBtn = $('#startBtn');
  const colorEl = $('#color'); const sizeEl = $('#size'); const speedEl = $('#speed'); const dwellEl = $('#dwell');
  const baseEl  = $('#base'); const ampxEl  = $('#ampx'); const ampyEl  = $('#ampy'); const ampzEl  = $('#ampz');
  const randEl  = $('#randomize'); const pickBtn = $('#pick'); const centerBtn = $('#centerMe');
  const moveModeEl = $('#moveMode'); const repeatAEl = $('#repeatA'); const repeatAText = $('#repeatAText');

  const toggleUiBtn = $('#toggleUiBtn');
  const pauseBtn = $('#pauseBtn');
  const showUiBtn = $('#showUiBtn');
  const uiEl = $('#ui');

  // Appearance init
  function applyAppearance(){
    const desiredR = Math.max(0.005, Number(params.sphereScale));
    const scaleFactor = desiredR / baseRadius;
    sphere.scale.setScalar(scaleFactor);
    const c = new THREE.Color(params.color);
    mat.color.set(c);
    mat.emissive.set(c);
    mat.emissiveIntensity = 0.15;
    mat.needsUpdate = true;
  }

  // Audio setup
  const AudioContextClass = window.AudioContext || window.webkitAudioContext; const audioCtx = new AudioContextClass();
  window.addEventListener('pointerdown', ()=>{ if (audioCtx.state === 'suspended') audioCtx.resume(); }, { once:true });

  // Background audio
  const audioEl = new Audio(); audioEl.loop = true; let bgSourceNode = null; const bgGain = audioCtx.createGain(); bgGain.gain.value=1.0; bgGain.connect(audioCtx.destination);
  const audioFile = $('#audioFile'); const fileStatus=$('#fileStatus'); const bgVol=$('#bgVol');
  audioFile.addEventListener('change', ()=>{ const f=audioFile.files && audioFile.files[0]; if(!f){ fileStatus.textContent='오디오 미선택'; return; } const url=URL.createObjectURL(f); audioEl.src=url; if(!bgSourceNode){ try{ bgSourceNode=audioCtx.createMediaElementSource(audioEl); bgSourceNode.connect(bgGain);}catch(e){} } audioEl.play().then(()=>{ fileStatus.textContent=`재생 중: ${f.name}`; if(audioCtx.state==='suspended') audioCtx.resume(); }).catch(()=>{ fileStatus.textContent=`로드됨: ${f.name} (사용자 입력 후 재생)`; }); });
  bgVol.addEventListener('input', e=>{ bgGain.gain.value=Number(e.target.value); });

  // Tick sound handling
  const tickGain = audioCtx.createGain(); tickGain.gain.value=0.8; tickGain.connect(audioCtx.destination);
  let tickBuffer=null; const tickFile=$('#tickFile'); const tickVol=$('#tickVol'); const tickStatus=$('#tickStatus');
  const tickPresetEl=document.getElementById('tickPreset'); const testPresetBtn=document.getElementById('testPreset');
  tickFile.addEventListener('change', async ()=>{ const f=tickFile.files && tickFile.files[0]; if(!f){ tickStatus.textContent='틱 소리 미선택'; tickBuffer=null; return; } const arr=await f.arrayBuffer(); try{ tickBuffer=await audioCtx.decodeAudioData(arr); tickStatus.textContent=`틱 로드됨: ${f.name}`; } catch(e){ tickStatus.textContent='디코딩 실패: '+e; tickBuffer=null; } });
  tickVol.addEventListener('input', e=>{ tickGain.gain.value=Number(e.target.value); });
  function envGainNode(t,a=0.005,d=0.12){ const g=audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(1.0,t+a); g.gain.exponentialRampToValueAtTime(0.0001,t+d); return g; }
  function makeNoiseBuffer(seconds){ const len=Math.max(1,Math.floor(audioCtx.sampleRate*seconds)); const buf=audioCtx.createBuffer(1,len,audioCtx.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<len;i++){ data[i]=Math.random()*2-1; } return buf; }
  function playPreset(name){ const t=audioCtx.currentTime; switch(name){
    case 'beep':{ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(880,t); const g=envGainNode(t,0.005,0.12); o.connect(g).connect(tickGain); o.start(t); o.stop(t+0.2); } break;
    case 'click':{ const s=audioCtx.createBufferSource(); s.buffer=makeNoiseBuffer(0.01); const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1200; const g=envGainNode(t,0.001,0.025); s.connect(hp).connect(g).connect(tickGain); s.start(t); s.stop(t+0.03);} break;
    case 'bell':{ const g=envGainNode(t,0.005,0.35); const o1=audioCtx.createOscillator(); o1.type='sine'; o1.frequency.setValueAtTime(880,t); const o2=audioCtx.createOscillator(); o2.type='sine'; o2.frequency.setValueAtTime(1320,t); o1.connect(g); o2.connect(g); g.connect(tickGain); o1.start(t); o2.start(t); o1.stop(t+0.45); o2.stop(t+0.45);} break;
    case 'pop':{ const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(120,t); const g=envGainNode(t,0.002,0.09); o.connect(g).connect(tickGain); o.start(t); o.stop(t+0.12);} break;
    case 'noise_hi':{ const s=audioCtx.createBufferSource(); s.buffer=makeNoiseBuffer(0.08); const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=2500; const g=envGainNode(t,0.003,0.06); s.connect(hp).connect(g).connect(tickGain); s.start(t); s.stop(t+0.09);} break;
    case 'noise_low':{ const s=audioCtx.createBufferSource(); s.buffer=makeNoiseBuffer(0.10); const lp=audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=600; const g=envGainNode(t,0.003,0.08); s.connect(lp).connect(g).connect(tickGain); s.start(t); s.stop(t+0.12);} break;
    case 'wood':{ const s=audioCtx.createBufferSource(); s.buffer=makeNoiseBuffer(0.06); const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1600; bp.Q.value=20; const g=envGainNode(t,0.001,0.05); s.connect(bp).connect(g).connect(tickGain); s.start(t); s.stop(t+0.07);} break;
    default: break; }
  }
  function playTurnTick(){ const preset=tickPresetEl.value; if (preset && preset!=='none'){ playPreset(preset); tickStatus.textContent=`프리셋 재생: ${tickPresetEl.options[tickPresetEl.selectedIndex].text}`; } else if (tickBuffer){ const s=audioCtx.createBufferSource(); s.buffer=tickBuffer; s.connect(tickGain); try{s.start(0);}catch{} tickStatus.textContent='업로드 파일 재생'; } else { tickStatus.textContent='프리셋 또는 업로드된 사운드가 없습니다'; } }
  document.getElementById('testPreset').addEventListener('click', ()=>{ try{ if (audioCtx.state==='suspended') audioCtx.resume(); }catch{} playTurnTick(); });

  // 360 video
  const vid360El=document.createElement('video'); vid360El.crossOrigin='anonymous'; vid360El.playsInline=true; vid360El.loop=true; vid360El.muted=false;
  let vid360Tex=null; let vid360SrcNode=null; const gain360=audioCtx.createGain(); gain360.gain.value=0.8; gain360.connect(audioCtx.destination);
  const vid360Input=$('#vid360'); const vid360Status=$('#vid360Status'); const play360Btn=$('#play360'); const clear360Btn=$('#clear360'); const vol360=$('#vol360');
  vid360Input.addEventListener('change', ()=>{ const f=vid360Input.files && vid360Input.files[0]; if(!f){ vid360Status.textContent='360 비디오 미선택'; return; } const url=URL.createObjectURL(f); vid360El.src=url; vid360El.load(); vid360Tex=new THREE.VideoTexture(vid360El); vid360Tex.colorSpace=THREE.SRGBColorSpace; vid360Tex.mapping=THREE.EquirectangularReflectionMapping; vid360Tex.minFilter=THREE.LinearFilter; vid360Tex.magFilter=THREE.LinearFilter; vid360Tex.generateMipmaps=false; scene.background=vid360Tex; if(!vid360SrcNode){ try{ vid360SrcNode=audioCtx.createMediaElementSource(vid360El); vid360SrcNode.connect(gain360);}catch(e){} } vid360El.play().then(()=>{ vid360Status.textContent=`360 재생 중: ${f.name}`; try{ if(audioCtx.state==='suspended') audioCtx.resume(); }catch{} }).catch(()=>{ vid360Status.textContent=`360 로드됨: ${f.name} (재생 버튼을 누르세요)`; }); });
  play360Btn.addEventListener('click', ()=>{ if(vid360El.paused) vid360El.play(); else vid360El.pause(); });
  clear360Btn.addEventListener('click', ()=>{ scene.background=new THREE.Color(0x000000); if(vid360Tex){ vid360Tex.dispose(); vid360Tex=null; } try{ vid360El.pause(); }catch{} vid360El.src=''; vid360Status.textContent='배경 비움'; });
  vol360.addEventListener('input', e=>{ gain360.gain.value=Number(e.target.value); });

  // 2D screen
  const screenGroup=new THREE.Group(); scene.add(screenGroup);
  const screenGeo=new THREE.PlaneGeometry(2.4,1.35,1,1); const screenMat=new THREE.MeshBasicMaterial({ color:0xffffff, side:THREE.DoubleSide }); const screenMesh=new THREE.Mesh(screenGeo,screenMat); screenGroup.add(screenMesh); screenGroup.visible=false;
  let vid2dEl=document.createElement('video'); vid2dEl.crossOrigin='anonymous'; vid2dEl.playsInline=true; vid2dEl.loop=true; vid2dEl.muted=false;
  let vid2dTex=null; let vid2dSrcNode=null; const gain2d=audioCtx.createGain(); gain2d.gain.value=0.8; gain2d.connect(audioCtx.destination);
  const vid2dInput=$('#vid2d'); const vid2dStatus=$('#vid2dStatus'); const play2dBtn=$('#play2d'); const hide2dBtn=$('#hide2d'); const vol2d=$('#vol2d'); const screenDist=$('#screenDist'); const screenWidth=$('#screenWidth');
  function updateScreenTransform(){ const dist=Number(screenDist.value); const xrCam=renderer.xr.isPresenting?renderer.xr.getCamera(camera):camera; xrCam.getWorldPosition(tmpPos); xrCam.getWorldDirection(tmpDir); screenGroup.position.copy(tmpPos).add(tmpDir.multiplyScalar(dist)); screenGroup.lookAt(tmpPos); }
  function applyScreenSize(){ const w=Number(screenWidth.value); let aspect=16/9; if(vid2dEl.videoWidth>0) aspect=vid2dEl.videoWidth/Math.max(1,vid2dEl.videoHeight); const h=w/aspect; screenMesh.scale.set(w/2.4, h/1.35, 1); }
  vid2dInput.addEventListener('change', ()=>{ const f=vid2dInput.files && vid2dInput.files[0]; if(!f){ vid2dStatus.textContent='2D 비디오 미선택'; return; } const url=URL.createObjectURL(f); vid2dEl.src=url; vid2dEl.load(); vid2dEl.onloadedmetadata=()=>{ applyScreenSize(); }; vid2dTex=new THREE.VideoTexture(vid2dEl); vid2dTex.colorSpace=THREE.SRGBColorSpace; vid2dTex.minFilter=THREE.LinearFilter; vid2dTex.magFilter=THREE.LinearFilter; vid2dTex.generateMipmaps=false; screenMat.map=vid2dTex; screenMat.needsUpdate=true; if(!vid2dSrcNode){ try{ vid2dSrcNode=audioCtx.createMediaElementSource(vid2dEl); vid2dSrcNode.connect(gain2d);}catch(e){} } screenGroup.visible=true; updateScreenTransform(); vid2dEl.play().then(()=>{ vid2dStatus.textContent=`2D 재생 중: ${f.name}`; try{ if(audioCtx.state==='suspended') audioCtx.resume(); }catch{} }).catch(()=>{ vid2dStatus.textContent=`2D 로드됨: ${f.name} (재생 버튼을 누르세요)`; }); });
  play2dBtn.addEventListener('click', ()=>{ if(vid2dEl.paused) vid2dEl.play(); else vid2dEl.pause(); });
  hide2dBtn.addEventListener('click', ()=>{ screenGroup.visible=!screenGroup.visible; });
  vol2d.addEventListener('input', e=>{ gain2d.gain.value=Number(e.target.value); });
  screenDist.addEventListener('input', ()=>{ updateScreenTransform(); });
  screenWidth.addEventListener('input', ()=>{ applyScreenSize(); });

  // Resize
  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // Init UI values
  colorEl.value=params.color; sizeEl.value=params.sphereScale; speedEl.value=params.moveSpeed; dwellEl.value=params.dwell; baseEl.value=params.base; ampxEl.value=params.ampx; ampyEl.value=params.ampy; ampzEl.value=params.ampz; randEl.checked=params.randomize; moveModeEl.value=params.moveMode; repeatAEl.value=params.presetRepeatA; repeatAText.textContent=String(params.presetRepeatA); applyAppearance();

  // Start logic
  function startExperience(){
    try { if (audioCtx.state==='suspended') audioCtx.resume(); } catch {}
    started = true; paused = false; sphere.visible = true; waitingAtTarget = false; turnReadyAt = 0;
    if (params.moveMode === 'random'){
      const center = new THREE.Vector3(); computeCenter(center); sphere.position.copy(center); pickNewTarget(false);
    } else {
      resetMotion(true);
    }
  }
  startBtn.addEventListener('click', startExperience);

  // Other UI handlers
  colorEl.addEventListener('input', e=>{ params.color=e.target.value; applyAppearance(); });
  sizeEl.addEventListener('input',  e=>{ params.sphereScale=Number(e.target.value); applyAppearance(); });
  speedEl.addEventListener('input', e=>{ params.moveSpeed=Number(e.target.value); });
  dwellEl.addEventListener('input', e=>{ params.dwell=Number(e.target.value); });
  baseEl.addEventListener('input',  e=>{ params.base=Number(e.target.value); if (started && params.moveMode!=='random') resetMotion(false); });
  ampxEl.addEventListener('input',  e=>{ params.ampx=Math.max(0.01,Number(e.target.value)); if (started && params.moveMode!=='random') resetMotion(false); });
  ampyEl.addEventListener('input',  e=>{ params.ampy=Math.max(0.01,Number(e.target.value)); });
  ampzEl.addEventListener('input',  e=>{ params.ampz=Math.max(0.01,Number(e.target.value)); if (started && params.moveMode!=='random') resetMotion(false); });
  randEl.addEventListener('change', e=>{ params.randomize=e.target.checked; });
  moveModeEl.addEventListener('change', ()=>{ params.moveMode=moveModeEl.value; if (started) resetMotion(true); });
  repeatAEl.addEventListener('input', ()=>{ const v=Math.max(3,Math.floor(Number(repeatAEl.value))); params.presetRepeatA=v; repeatAText.textContent=String(v); if (presetPhase==='A') aRemain=Math.max(1,v); });
  pickBtn.addEventListener('click', ()=>{ if(!started) return; try{ if (audioCtx.state==='suspended') audioCtx.resume(); }catch{} resetMotion(true); });
  centerBtn.addEventListener('click', ()=>{ if(!started) return; resetMotion(true); });

  // Toggle UI
  toggleUiBtn.addEventListener('click', ()=>{
    if (uiEl.style.display === 'none'){ uiEl.style.display = ''; showUiBtn.style.display = 'none'; toggleUiBtn.textContent = 'UI 숨기기'; }
    else { uiEl.style.display = 'none'; showUiBtn.style.display = 'block'; showUiBtn.focus(); }
  });
  showUiBtn.addEventListener('click', ()=>{ uiEl.style.display = ''; showUiBtn.style.display = 'none'; toggleUiBtn.textContent = 'UI 숨기기'; });

  // Pause/resume (also pauses media)
  pauseBtn.addEventListener('click', async ()=>{
    paused = !paused;
    if (paused){
      try { wasBgPlaying = !!(audioEl && !audioEl.paused && audioEl.currentTime > 0 && !audioEl.ended); } catch(e){ wasBgPlaying = false; }
      try { wasVid360Playing = !!(vid360El && !vid360El.paused && vid360El.currentTime > 0 && !vid360El.ended); } catch(e){ wasVid360Playing = false; }
      try { wasVid2dPlaying = !!(vid2dEl && !vid2dEl.paused && vid2dEl.currentTime > 0 && !vid2dEl.ended); } catch(e){ wasVid2dPlaying = false; }

      try { if (audioEl && !audioEl.paused) audioEl.pause(); } catch(e){}
      try { if (vid360El && !vid360El.paused) vid360El.pause(); } catch(e){}
      try { if (vid2dEl && !vid2dEl.paused) vid2dEl.pause(); } catch(e){}

      pauseBtn.textContent = '재생';
      pauseBtn.title = '다시 재생';
    } else {
      try { if (audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
      try { if (audioEl && wasBgPlaying) { await audioEl.play().catch(()=>{}); } } catch(e){}
      try { if (vid360El && wasVid360Playing) { await vid360El.play().catch(()=>{}); } } catch(e){}
      try { if (vid2dEl && wasVid2dPlaying) { await vid2dEl.play().catch(()=>{}); } } catch(e){}

      pauseBtn.textContent = '일시정지';
      pauseBtn.title = '일시정지';
    }
  });

  // Animate loop
  const clock=new THREE.Clock();
  renderer.setAnimationLoop(()=>{
    const dt=clock.getDelta();

    if (screenGroup.visible) updateScreenTransform();

    if (!started){ renderer.render(scene,camera); return; }
    if (paused){ renderer.render(scene,camera); return; }

    const followRate=THREE.MathUtils.lerp(2.0,6.0,THREE.MathUtils.clamp(params.moveSpeed,0.1,3.0));
    sphere.position.lerp(currentTarget, THREE.MathUtils.clamp(dt*followRate,0,1));

    const arrived=sphere.position.distanceToSquared(currentTarget)<arrivalThreshSq; const now=performance.now();
    if(arrived && !waitingAtTarget){ waitingAtTarget=true; turnReadyAt=now + params.dwell*1000; playTurnTick(); }
    if(waitingAtTarget && now>=turnReadyAt){ waitingAtTarget=false; if(params.moveMode==='random'){ if(params.randomize) pickNewTarget(false); } else { nextPresetTarget(); } }

    renderer.render(scene,camera);
  });

  console.log('Script initialized — ready. Press "재생 시작" to show the globe.');
</script>
</body>
</html>